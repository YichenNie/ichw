# ichw2
Assignments of Introduction to Computing B

**需要Chrome浏览器插件[GitHub with MathJax](https://chrome.google.com/webstore/detail/github-with-mathjax/ioemnmodlmafdkllaclgeombjnmnbima)才能正确显示公式.**


### 1. 用你的语言描述图灵为什么要证明停机问题, 其证明方法和数学原理是什么.
停机问题指的是
>是否存在一个方法，能判断任意一个程序在有限时间内停机或永远循环.

图灵证明了上述问题并没有通解. 在证明过程中，图灵使用了[对角论证法](https://zh.wikipedia.org/wiki/對角論證法). 对角论证法最早由康托尔提出，用以解决下面这个问题
>\[0,1\]之间的每一个数，能否一一对应自然数集$ \mathbb N = {0,1,2,3...} $中的每一个数.

其简略的证明过程是
>1. 假设\[0,1\]之间的每一个数${x_1, x_2, ...,x_n,...}$，能一一对应自然数集$ \mathbb N = {0,1,2,3...} $中的每一个数.  那么将其排成一列，并表示成小数形式. 如下所示

>|n|$x_n$|
>|:-:|:-:|
>|0|0.**4**68476799...|
>|1|0.6**8**7544676...|
>|2|0.98**6**742356...|
>|3|0.675**4**56887...|
>|4|0.1441**4**4144...|
>|...|...|

>2. 取出每一个$x_n$的第n位小数，如上面粗体所示.
>3. 构造一个新数$y=0.\, ...$,它的第n位小数用下面这个方法产生
 >> **如果$x_n$的第n位小数为4，那么$y$的第n位小数为1.**  
 >> **如果$x_n$的第n位小数不为4，那么$y$的第n位小数为4.**
>4. 这里$y$不可能与任何$x$相等. 因为$y$和$x$的第n位小数一定不相等.
>5. $y$是\[0,1\]之间的数，然而它却不能对应自然数集中的任何一个数.
>6. 产生矛盾，所以假设错误.

图灵证明停机问题采用的方法和上面第3步中粗体部分类似，证明过程如下

>1. 假设存在能判断任意一个程序是否能停机的方法.那么构造程序g：
 >> **如果输入的程序(program)会无限循环，则返回停机.**
 >> **如果输入的程序会停机，则返回无限循环.**
>2. 那么如果上述程序输入自己，那么该程序是否会停机？

这与[理发师悖论](https://zh.wikipedia.org/wiki/理发师悖论)有相同的原理，也就是
>1. 假设村里有一位理发师，他说：
 >> **如果村里的人自己给自己理发，那么他就不给这些人理发.**
 >> **如果村里的人不给自己理发，那么他就给这些人理发.**
>2. 那么该理发师给不给自己理发？

如果理发师给自己理发，那么他就属于第一种情况，所以他就不该给自己理发。相反的，如果理发师给自己理发，那么他就属于第二种情况，那么他就应该给自己理发。这就陷入了悖论。停机问题与之类似，所以也存在相应的悖论，图灵也就以此证明了停机问题无解。

### 2. 你在向中学生做科普，请向他们解释二进制补码的原理.
首先，我们先看不存在补码时，二进制下，整数的加法（整数用8位二进制数表示，第一位表示符号）：

|十进制运算|二进制运算|二进制结果|二进制结果转换成十进制|
|:-:|:-:|:-:|:-:|
|1+1|0000 0001+0000 0001|0000 0010|2|
|2+32|0000 0010+0010 0000|0010 0010|34|

可以看见，这并不存在什么问题.然而当我们在做减法，或负数的加法时：

|十进制运算|二进制运算|二进制结果|二进制结果转换成十进制|
|:-:|:-:|:-:|:-:|
|1+(-2)|0000 0001+1000 0010|1000 0011|-3|
|3+(-2)|0000 0011+1000 0010|1000 0101|-5|

这就出现问题了，1+(-2)或者说1-2应当等于-1，而按照这种算法，最后给出了-3.

为了克服这一问题，最简单的方法就是将计算过程变成：

1+(-2)=1+(126-128)=(1+126)-128=127-128=-1

换言之，如果有一个128个小格的钟表，上面表示1即指针顺时针转动1个小格.表示(-2)即逆时针转动2个小格，也就相当于顺时针转动126个小格.

在计算1+(-2)时，则先从指针指向0开始，顺时针先拨1小格，再拨126个小格，此时表上显示的应当是顺时针拨动127个小格，它可以表示127或(-1).随后我们再考虑第一位，得出最后的结果-1.

将-2转换为126的过程，在二进制中，就是一个求补码的过程.


在这之前，


### 3. 某基于 IEEE 754浮点数格式的 16 bit 浮点数表示, 有 8 个小数位, 请给出 ±0, ±1.0, 最大非规范化数, 最小非规范化数, 最小规范化浮点数, 最大规范化浮点数, ±∞, NaN 的二进制表示.

|数|二进制数|十进制表示|
|:------------:|:---------------------:|:--------------:|
|+0|0000 0000 0000 0000|0|
|-0|1000 0000 0000 0000|0|
|+1.0|0011 1111 0000 0000|1|
|-1.0|1011 1111 0000 0000|-1|
|最大非规范化数|\*000 0000 1111 1111|$ \pm (1-2^{-8})\times 2^{-62} $|
|最小非规范化数|\*000 0000 0000 0001|$ \pm 2^{-8}\times 2^{-62} $|
|最小规范化浮点数|\*000 0001 0000 0000|$ \pm 1\times 2^{-62} $|
|最大规范化浮点数|\*111 1110 1111 1111|$ \pm (2-2^{-8})\times 2^{63} $|
|±∞|\*111 1111 0000 0000|$ \pm \infty $|
|NaN|\*111 1111 小数部分非零|NaN|
